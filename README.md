# Simulated Annealing
***
## Purpose of the Program
---
For this problem, I simulated the annealing process by using _T' = 0.99T_ as the "cooling" function, _R_ is a randomly generated real number between 0 and 1 (inclusive), _Eval(x')_ is the y-coordinate generated by perturbing _x_, and _Eval(x)_ is the y-coordinate evaluated at the current _x_.

To perturb _x_, I used the following formula:

_x' = x + R_

_R_ here is a randomly generated real number between -1 and 1, such that _0 < x' < 1_.  In cases where _x'_ falls outside of that range, the random number _R_ is selected for again, until _0 greater than x' less than 1_ is satisfied _(see Code section below for implementation details)_.

Displayed below in the **Results** section is a table demonstrating 8 trials run on the algorithm.  I paired up like trials.  Each pair of trials differs by the subsequent pair only by the initial _T_ (Temperature) used for the simulation.  The terminal Temperature was fixed at 0.0001 units and was used as the terminating condition for the while-loop in the algorithm.

Also displayed below are three plots.  One demonstrates a run on a typical "greedy" hill climb algorithm, the second demonstrates a simulated annealing trial run(corresponding run number from the table indicated in the plot caption), and the last plot graphs the _Eval(x)_ as a function of total algorithmic iterations (or time).  The _Eval(x) vs. Iterations_ plot proves especially illustrative by showing how the simulated annealing algorithm allows for wide sub-optimal _Eval(x)_ acceptance from the beginning of the trial, but progressively narrows the acceptance rate throughout.  At the tail end of the algorithm's cycle, the annealing formula only accepts _Eval(x)_'s that improve the chances of the desired outcome, _Eval(x) = 1.0_.

Because I only changed the initial Temperature from one trial to the next, the overall behavior of the simulation changed primarily in length of time.  I found after hours of testing that my current method proved to be quite effective in estimating the global maximum of the function most of the time, and that changes to the perturbation or shape of the Temperature function did not prove to add much value in that regard.  By extending the precision of the Temperature function _T' = 0.99T_ to something like _T' = 0.999T_ or _T' = 0.9999T_, the number of iterations dramatically changes (and therefore the length of time needed to execute the algorithm), however the general behavior of the algorithm does not.  There are, of course, other approaches that would change the behavior in noticeable ways - such as making the perturbation function dependent on another variable or changing the Temperature function - but, I chose to stick with the aforementioned due to it's overall effectiveness and relatively low computational burden.

## References
---
_For supplemental reading on simulated annealing:_
* [Wikipedia](https://en.wikipedia.org/wiki/Simulated\_annealing)

_For supplemental help coding in Python:_
* [Geeks For Geeks](https://www.geeksforgeeks.org/)
* [Stack Overflow](https://www.stackoverflow.com/questions/)
* [Matplotlib](https://matplotlib.org/3.1.1/tutorials/introductory/pyplot.html)

_For supplemental help with LaTeX:_
* [OverLeaf](https://www.overleaf.com/learn/latex/)

## Results
---
Here is the sequence of trial runs on the simulated annealing algorithm.  Notice that increase in Temperature corresponds to increased iterations (and therefore increased computing time).

|Trial|Init. Temp|Term. Temp|Iterations|Eval(x)| 
|-----|----------|----------|----------|-------|
|1|1|0.001|688|0.9990| 
|2|1|0.001|688|0.9905|
|3|10|0.001|917|1.000|
|4|10|0.001|917|0.9995|
|5|100|0.001|1146|0.9987| 
|6|100|0.001|1146|1.000|
|7|1000|0.001|1375|0.9965|
|8|1000|0.001|1375|0.987 | 

Here is a plot of a determistic, "greedy" hill-climbing simulation.  The global max is actually located on the left-most peak of the graph, but because the search space (deviation) of x is limited to +/- 0.01, the algorithm always takes the next best _Eval(x)_, resulting in it's terminating at the top of the middle peak.
![Deterministic Hill Climb](https://github.com/CodeCommandante/ThePeoplesRepo/tree/main/Natural%20Computing/Simulated%20Annealing/plots/DetHillClimb_ex.png)

The results from Trial 3 in the Table 1 above.  The yellow triangles indicate the optimal or sub-optimal _Eval(x)_'s that were accepted by the simulated annealing formula throughout the course of the simulation.
![Simulated Annealing](https://github.com/CodeCommandante/ThePeoplesRepo/tree/main/Natural%20Computing/Simulated%20Annealing/plots/SimAnneal.png)

Shows the change in _Eval(x)_ over the course of Trial 3
![Estimated vs Iterations](https://github.com/CodeCommandante/ThePeoplesRepo/tree/main/Natural%20Computing/Simulated%20Annealing/plots/EstVSIt.png)

## Credits
Additional credit to Dr. Jeff McGough from South Dakota School of Mines and Technology for providing his students with these fun and challenging problems.